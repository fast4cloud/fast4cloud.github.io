(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{340:function(t,s,a){"use strict";a.r(s);var e=a(13),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"雪花算法组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#雪花算法组件"}},[t._v("#")]),t._v(" 雪花算法组件")]),t._v(" "),s("h2",{attrs:{id:"引入maven-包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引入maven-包"}},[t._v("#")]),t._v(" 引入maven 包")]),t._v(" "),s("div",{staticClass:"language-xml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-xml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("dependency")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("groupId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("com.fast4cloud"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("groupId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("artifactId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("framework-starter-snowfrake-id"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("artifactId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("dependency")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h2",{attrs:{id:"当前使用算法包版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当前使用算法包版本"}},[t._v("#")]),t._v(" 当前使用算法包版本")]),t._v(" "),s("div",{staticClass:"language-xml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-xml"}},[s("code",[t._v("        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!--雪花算法包--\x3e")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("dependency")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("groupId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("com.github.yitter"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("groupId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("artifactId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("yitter-idgenerator"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("artifactId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("version")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("1.0.6"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("version")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("dependency")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("h2",{attrs:{id:"在yml-配置信息如下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在yml-配置信息如下"}},[t._v("#")]),t._v(" 在yml 配置信息如下")]),t._v(" "),s("div",{staticClass:"language-yaml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 自定义配置")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("config")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#雪花算法")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("yitter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 表示使用什么算法，默认值为1，表示使用雪花漂移算法，2表示使用传统雪花算法。但仍建议你使用雪花漂移算法（Method=1，默认的），毕竟它具有更好的伸缩力和更高的性能。")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("method")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 基础时间（也称：基点时间、原点时间、纪元时间），默认值为：2022-01-01 00:00:00，是毫秒时间戳（是整数，.NET是DatetTime类型），作用是：用生成ID时的系统时间与基础时间的差值（毫秒数）作为生成ID的时间戳。基础时间一般无需设置，如果觉得默认值太老，你可以重新设置，不过要注意，这个值以后最好不变。")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("baseTime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1640966400000")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 机器码，最重要参数，默认值0，必须 全局唯一（或相同 DataCenterId 内唯一），必须 程序设定，缺省条件（WorkerIdBitLength取默认值）时最大值63，理论最大值 2^WorkerIdBitLength-1（不同实现语言可能会限定在 65535 或 32767，原理同 WorkerIdBitLength 规则）")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("workerId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 机器码位长，决定 WorkerId 的最大值，默认值1，取值范围 [1, 19]，实际上有些语言采用 无符号 ushort (uint16) 类型接收该参数，所以最大值是16，如果是采用 有符号 short (int16)，则最大值为15。")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("workerIdBitLength")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 序列数位长，默认值6，取值范围 [3, 21]（建议不小于4），决定每毫秒基础生成的ID个数。规则要求：WorkerIdBitLength + SeqBitLength 不超过 22。")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("seqBitLength")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最小序列数，默认值5，取值范围 [5, MaxSeqNumber]，每毫秒的前5个序列数对应编号0-4是保留位，其中0是手工插入新值预留位，1-4是时间回拨相应预留位。")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("minSeqNumber")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最大序列数，设置范围 [MinSeqNumber, 2^SeqBitLength-1]，默认值0，真实最大序列数取最大值（2^SeqBitLength-1），不为0时，取其为真实最大序列数，一般无需设置，除非多机共享WorkerId分段生成ID（此时还要正确设置最小序列数）。")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("maxSeqNumber")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最大漂移次数，与计算能力有关")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("topOverCostCount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2000")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br")])]),s("h2",{attrs:{id:"实际使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实际使用"}},[t._v("#")]),t._v(" 实际使用")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化以后，即可在任何需要生成ID的地方，调用以下方法：")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" newId "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FdSnowFrakeIdUtil")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getLongId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" newId "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FdSnowFrakeIdUtil")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getStrId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h2",{attrs:{id:"目录结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[t._v("#")]),t._v(" 目录结构")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("│ ├─config                   配置目录\n│ |  ├─SnowFrakeConfig       初始化配置\n| |  └─SnowFrakeProperties   自定义properties配置+\n| └─utils                    工具类\n|    └─FdSnowFrakeIdUtil     实际使用工具类\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[s("em",[s("strong",[t._v("引用")])])]),t._v(" "),s("h2",{attrs:{id:"技术支持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#技术支持"}},[t._v("#")]),t._v(" 技术支持")]),t._v(" "),s("p",[t._v("开源地址：https://github.com/yitter/IdGenerator")]),t._v(" "),s("p",[t._v("QQ群：646049993")]),t._v(" "),s("h2",{attrs:{id:"💎-算法介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#💎-算法介绍"}},[t._v("#")]),t._v(" 💎 算法介绍")]),t._v(" "),s("p",[t._v("❄ 这是优化的雪花算法（雪花漂移），它生成的ID更短、速度更快。")]),t._v(" "),s("p",[t._v("❄ 支持 k8s 等容器环境自动扩容（自动注册 WorkerId），可在单机或分布式环境生成数字型唯一ID。")]),t._v(" "),s("p",[t._v("❄ 原生支持 C#/Java/Go/Rust/C/SQL/Node.js/PHP(C扩展) 等语言，并提供Python、PB多线程安全调用动态库（FFI）。")]),t._v(" "),s("p",[t._v("❄ 兼容所有雪花算法（号段模式或经典模式，大厂或小厂），将来你可做任意的升级切换。（一般无须升级，但理论上支持）")]),t._v(" "),s("p",[t._v("❄ 这是计算机历史上最全面的雪花ID生成工具。")]),t._v(" "),s("h4",{attrs:{id:"需求来源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#需求来源"}},[t._v("#")]),t._v(" 需求来源")]),t._v(" "),s("p",[t._v("💧 作为架构设计的你，想要解决数据库主键唯一的问题，特别是在分布式系统多数据库中。")]),t._v(" "),s("p",[t._v("💧 你希望数据表主键用最少的存储空间，索引速度更快，Select、Insert 和 Update 更迅速。")]),t._v(" "),s("p",[t._v("💧 你要考虑在分库分表（合库合表）时，主键值可直接使用，并能反映业务时序。")]),t._v(" "),s("p",[t._v("💧 如果这样的主键值太长，超过前端 js Number 类型最大值，须把 Long 型转换为 String 型，你会觉得有点沮丧。")]),t._v(" "),s("p",[t._v("💧 尽管 Guid 能自增，但占用空间大，索引速度慢，你不想用它。")]),t._v(" "),s("p",[t._v("💧 应用实例可能超过50个，每个并发请求可达10W/s。")]),t._v(" "),s("p",[t._v("💧 要在容器环境部署应用，支持水平复制、自动扩容。")]),t._v(" "),s("p",[t._v("💧 不想依赖 redis 的自增操作获得连续的主键ID，因为连续的ID存在业务数据安全风险。")]),t._v(" "),s("p",[t._v("💧 你希望系统运行 100 年以上。")]),t._v(" "),s("h4",{attrs:{id:"传统算法问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传统算法问题"}},[t._v("#")]),t._v(" 传统算法问题")]),t._v(" "),s("p",[t._v("❌ 生成的ID太长。")]),t._v(" "),s("p",[t._v("❌ 瞬时并发量不够。")]),t._v(" "),s("p",[t._v("❌ 不能解决时间回拨问题。")]),t._v(" "),s("p",[t._v("❌ 不支持后补生成前序ID。")]),t._v(" "),s("p",[t._v("❌ 可能依赖外部存储系统。")]),t._v(" "),s("h4",{attrs:{id:"新算法特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新算法特点"}},[t._v("#")]),t._v(" 新算法特点")]),t._v(" "),s("p",[t._v("✔ 整形数字，随时间单调递增（不一定连续），长度更短，用50年都不会超过 js Number类型最大值。（默认配置）")]),t._v(" "),s("p",[t._v("✔ 速度更快，是传统雪花算法的2-5倍，0.1秒可生成50万个（基于8代低压i7）。")]),t._v(" "),s("p",[t._v("✔ 支持时间回拨处理。比如服务器时间回拨1秒，本算法能自动适应生成临界时间的唯一ID。")]),t._v(" "),s("p",[t._v("✔ 支持手工插入新ID。当业务需要在历史时间生成新ID时，用本算法的预留位能生成5000个每秒。")]),t._v(" "),s("p",[t._v("✔ 不依赖任何外部缓存和数据库。（k8s环境下自动注册 WorkerId 的动态库依赖 redis）")]),t._v(" "),s("p",[t._v("✔ 基础功能，开箱即用，无需配置文件、数据库连接等。")]),t._v(" "),s("h4",{attrs:{id:"性能数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能数据"}},[t._v("#")]),t._v(" 性能数据")]),t._v(" "),s("p",[t._v("(参数：10位自增序列，1000次漂移最大值)")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("连续请求量")]),t._v(" "),s("th",[t._v("5K")]),t._v(" "),s("th",[t._v("5W")]),t._v(" "),s("th",[t._v("50W")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("传统雪花算法")]),t._v(" "),s("td",[t._v("0.0045s")]),t._v(" "),s("td",[t._v("0.053s")]),t._v(" "),s("td",[t._v("0.556s")])]),t._v(" "),s("tr",[s("td",[t._v("雪花漂移算法")]),t._v(" "),s("td",[t._v("0.0015s")]),t._v(" "),s("td",[t._v("0.012s")]),t._v(" "),s("td",[t._v("0.113s")])])])]),t._v(" "),s("p",[t._v("💍 极致性能：500W/s~3000W/s。（所有测试数据均基于8代低压i7计算）")]),t._v(" "),s("h4",{attrs:{id:"如何处理时间回拨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何处理时间回拨"}},[t._v("#")]),t._v(" 如何处理时间回拨")]),t._v(" "),s("p",[t._v("🔶 当发生系统时间回拨时，算法采用过去时序的预留序数生成新的ID。")]),t._v(" "),s("p",[t._v("🔶 回拨生成的ID序号，默认靠前，也可以调整为靠后。")]),t._v(" "),s("p",[t._v("🔶 允许时间回拨至本算法预设基数（参数可调）。")]),t._v(" "),s("h2",{attrs:{id:"💎-id组成说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#💎-id组成说明"}},[t._v("#")]),t._v(" 💎 ID组成说明")]),t._v(" "),s("ul",[s("li",[t._v("本算法生成的ID由3部分组成（沿用雪花算法定义）：")]),t._v(" "),s("li",[t._v("+-------------------------+--------------+----------+")]),t._v(" "),s("li",[t._v("| 1.相对基础时间的时间差 | 2.WorkerId | 3.序列数 |")]),t._v(" "),s("li",[t._v("+-------------------------+--------------+----------+")]),t._v(" "),s("li"),t._v(" "),s("li",[t._v("第1部分，时间差，是生成ID时的系统时间减去 BaseTime 的总时间差（毫秒单位）。")]),t._v(" "),s("li",[t._v("第2部分，WorkerId，是区分不同机器或不同应用的唯一ID，最大值由 WorkerIdBitLength（默认6）限定。")]),t._v(" "),s("li",[t._v("第3部分，序列数，是每毫秒下的序列数，由参数中的 SeqBitLength（默认6）限定。")])]),t._v(" "),s("h4",{attrs:{id:"id示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#id示例"}},[t._v("#")]),t._v(" ID示例")]),t._v(" "),s("p",[t._v("🟣 本算法生成的 ID ，是整数（占用空间最多8字节），以下是基于默认配置生成的ID：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("129053495681099        (运行1年)\n387750301904971        (运行3年)\n646093214093387        (运行5年)\n1292658282840139       (运行10年)\n9007199254740992       (js Number 最大值，可以支撑70年)\n165399880288699493     (普通雪花算法生成的ID)\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("🟣 本算法生成的 ID 值，是 js Number 最大值的 1%-10%，是普通雪花算法值的千分之一，而生成速度却超过普通雪花算法。")]),t._v(" "),s("p",[t._v("🟣 js Number 类型最大数值：9007199254740992，本算法在保持并发性能（5W+/0.01s）和最大64个 WorkerId（6bit）的同时，能用70年才到 js Number Max 值。")]),t._v(" "),s("h3",{attrs:{id:"长度估算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#长度估算"}},[t._v("#")]),t._v(" 长度估算")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("💍 每增加 1位 WorkerIdBitLength 或 SeqBitLength，生成的ID数字值将会乘以2（基础长度可参考前一节“ID示例”），反之则除以2。\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"能用多久"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#能用多久"}},[t._v("#")]),t._v(" 能用多久")]),t._v(" "),s("p",[t._v("能用多久的解释，是指生成的ID数字，何时能增长到超过 long（有符号64位，8字节）最大值。")]),t._v(" "),s("p",[t._v("🔵 在默认配置下，ID可用 71000 年不重复。")]),t._v(" "),s("p",[t._v("🔵 在支持 1024 个工作节点时，ID可用 4480 年不重复。")]),t._v(" "),s("p",[t._v("🔵 在支持 4096 个工作节点时，ID可用 1120 年不重复。")]),t._v(" "),s("h3",{attrs:{id:"补充说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补充说明"}},[t._v("#")]),t._v(" 补充说明")]),t._v(" "),s("p",[t._v("❄ 默认算法，每个时间戳开始，生成的ID是奇数。")]),t._v(" "),s("p",[t._v("❄ 可以把ID右移 WorkerIdBitLength+SeqBitLength，得到时间戳。")]),t._v(" "),s("h2",{attrs:{id:"💎-参数设置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#💎-参数设置"}},[t._v("#")]),t._v(" 💎 参数设置")]),t._v(" "),s("p",[t._v("❄ "),s("em",[s("strong",[t._v("WorkerIdBitLength")])]),t._v("，机器码位长，决定 WorkerId 的最大值，"),s("strong",[t._v("默认值6")]),t._v("，取值范围 [1, 19]，实际上有些语言采用 无符号 ushort (uint16)\n类型接收该参数，所以最大值是16，如果是采用 有符号 short (int16)，则最大值为15。")]),t._v(" "),s("p",[t._v("❄ "),s("strong",[t._v("WorkerId")]),t._v("，机器码，"),s("strong",[t._v("最重要参数")]),t._v("，无默认值，必须 "),s("strong",[t._v("全局唯一")]),t._v("（或相同 DataCenterId 内唯一），必须 "),s("strong",[t._v("程序设定")]),t._v("，缺省条件（WorkerIdBitLength取默认值）时最大值63，理论最大值\n2^WorkerIdBitLength-1（不同实现语言可能会限定在 65535 或 32767，原理同 WorkerIdBitLength 规则）。不同机器或不同应用实例 "),s("strong",[t._v("不能相同")]),t._v("\n，你可通过应用程序配置该值，也可通过调用外部服务获取值。针对自动注册WorkerId需求，本算法提供默认实现：通过 redis 自动注册 WorkerId 的动态库，详见“Tools\\AutoRegisterWorkerId”。")]),t._v(" "),s("p",[s("strong",[t._v("特别提示")]),t._v("：如果一台服务器部署多个独立服务，需要为每个服务指定不同的 WorkerId。")]),t._v(" "),s("p",[t._v("❄ "),s("em",[s("strong",[t._v("SeqBitLength")])]),t._v("，序列数位长，"),s("strong",[t._v("默认值6")]),t._v("，取值范围 [3, 21]（建议不小于4），决定每毫秒基础生成的ID个数。规则要求：WorkerIdBitLength + SeqBitLength 不超过 22。")]),t._v(" "),s("p",[t._v("❄ "),s("em",[s("strong",[t._v("MinSeqNumber")])]),t._v("，最小序列数，默认值5，取值范围 [5, MaxSeqNumber]，每毫秒的前5个序列数对应编号0-4是保留位，其中1-4是时间回拨相应预留位，0是手工新值预留位。")]),t._v(" "),s("p",[t._v("❄ "),s("em",[s("strong",[t._v("MaxSeqNumber")])]),t._v("，最大序列数，设置范围 [MinSeqNumber, 2^SeqBitLength-1]\n，默认值0，真实最大序列数取最大值（2^SeqBitLength-1），不为0时，取其为真实最大序列数，一般无需设置，除非多机共享WorkerId分段生成ID（此时还要正确设置最小序列数）。")]),t._v(" "),s("p",[t._v("❄ "),s("em",[s("strong",[t._v("BaseTime")])]),t._v("\n，基础时间（也称：基点时间、原点时间、纪元时间），有默认值（2020年），是毫秒时间戳（是整数，.NET是DatetTime类型），作用是：用生成ID时的系统时间与基础时间的差值（毫秒数）作为生成ID的时间戳。基础时间一般无需设置，如果觉得默认值太老，你可以重新设置，不过要注意，这个值以后最好不变。")]),t._v(" "),s("p",[t._v("第二版增加参数（非必须）：")]),t._v(" "),s("p",[t._v("❄ "),s("em",[s("strong",[t._v("DataCenterId")])]),t._v("，数据中心ID（机房ID，默认0），请确保全局唯一。")]),t._v(" "),s("p",[t._v("❄ "),s("em",[s("strong",[t._v("DataCenterIdBitLength")])]),t._v("，数据中心ID长度（默认0）。")]),t._v(" "),s("p",[t._v("❄ "),s("em",[s("strong",[t._v("TimestampType")])]),t._v("，时间戳类型（0-毫秒，1-秒），默认0。")]),t._v(" "),s("h4",{attrs:{id:"常规集成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常规集成"}},[t._v("#")]),t._v(" 常规集成")]),t._v(" "),s("p",[t._v("1️⃣ 用单例模式调用。外部集成方使用更多的实例并行调用本算法，不会增加ID产出效能，因为本算法采用单线程生成ID。")]),t._v(" "),s("p",[t._v("2️⃣ 指定唯一的 WorkerId。必须由外部系统确保 WorkerId 的全局唯一性，并赋值给本算法入口方法。")]),t._v(" "),s("p",[t._v("3️⃣ 单机多实例部署时使用不同 WorkerId。并非所有实现都支持跨进程的并发唯一，保险起见，在同一主机上部署多应用实例时，请确保各 WorkerId 唯一。")]),t._v(" "),s("p",[t._v("4️⃣ 异常处理。算法会抛出所有 Exception，外部系统应 catch 异常并做好应对处理，以免引发更大的系统崩溃。")]),t._v(" "),s("p",[t._v("5️⃣ 认真理解 IdGeneratorOptions 的定义，这对集成和使用本算法有帮助。")]),t._v(" "),s("p",[t._v("6️⃣ 使用雪花漂移算法。虽然代码里包含了传统雪花算法的定义，并且你可以在入口处指定（Method=2）来启用传统算法，但仍建议你使用雪花漂移算法（Method=1，默认的），毕竟它具有更好的伸缩力和更高的性能。")]),t._v(" "),s("p",[t._v("7️⃣ 不要修改核心算法。本算法内部参数较多，逻辑较为复杂，在你尚未掌握核心逻辑时，请勿修改核心代码且用于生产环境，除非通过大量细致、科学的测试验证。")]),t._v(" "),s("p",[t._v("8️⃣ 应用域内配置策略相同。当系统运行一段时间后，项目需要从程序指定 WorkerId 转到自动注册 WorkerId 时，请确保同一应用域内所有在用实例采用一致的配置策略，这不仅仅针对 WorkerId，也包含其他所有配置参数。")]),t._v(" "),s("p",[t._v("9️⃣ 管理好服务器时间。雪花算法依赖系统时间，不要手工大幅度回调操作系统时间。如果一定要调整，切记：确保服务再次启动时的系统时间大于最后一次关闭时的时间。（注：世界级或网络级的时间同步或回拨，引起的系统时间小幅度变化，对本算法没影响）")]),t._v(" "),s("h4",{attrs:{id:"配置变更"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置变更"}},[t._v("#")]),t._v(" 配置变更")]),t._v(" "),s("p",[t._v("配置变更指是系统运行一段时间后，再调整运行参数（IdGeneratorOptions 选项值），请注意：")]),t._v(" "),s("p",[t._v("🔴 1.最重要的一条原则是：BaseTime "),s("strong",[t._v("只能往前")]),t._v("（比老值更小、距离现在更远）赋值，原因是往后赋值极大可能产生相同的时间戳。["),s("strong",[t._v("不推荐")]),t._v("在系统运行之后调整 BaseTime]")]),t._v(" "),s("p",[t._v("🔴 2.任何时候增加 WorkerIdBitLength 或 SeqBitLength，都是可以的，但是慎用 “减小”的操作，因为这可能导致在未来某天生成的 ID 与过去老配置时相同。[允许在系统运行之后**\n增加**任何一个 BitLength 值]")]),t._v(" "),s("p",[t._v("🔴 3.如果必须减小 WorkerIdBitLength 或 SeqBitLength 其中的一项，一定要满足一个条件：新的两个 BitLength 之和要大于 老的值之和。["),s("strong",[t._v("不推荐")]),t._v("在运行之后缩小任何一个 BitLength 值]")]),t._v(" "),s("p",[t._v("🔴 4.上述3条规则，并未在本算法内做逻辑控制，集成方应根据上述规则做好影响评估，确认无误后，再实施配置变更。")]),t._v(" "),s("h2",{attrs:{id:"自动注册workerid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动注册workerid"}},[t._v("#")]),t._v(" 自动注册WorkerId")]),t._v(" "),s("p",[t._v("🔍 唯一ID生成器，依赖WorkerId，当业务服务需要水平无差别复制（自动扩容）时，这就要求能自动注册全局唯一WorkerId，然后才能生产唯一ID。")]),t._v(" "),s("p",[t._v("🔍 本算法提供开源动态库（go语言实现），能在容器 k8s 等容器环境下，通过 redis 自动注册 WorkerId。")]),t._v(" "),s("p",[t._v("🔍 通过redis注册WorkerId，并非唯一方法。你还可以开发中心化的配置服务，各端点服务启动时，通过中心服务获取唯一 WorkerId。")]),t._v(" "),s("p",[t._v("🔍 当然，如果你的服务无需自动扩容，那就不必自动注册WorkerId，而是为它们分别设置全局唯一值。")]),t._v(" "),s("p",[t._v("🔍 方法还有很多，例如：开发中心化的ID生成服务，由它为各端点服务（单个或批量）生成可用ID。")]),t._v(" "),s("h4",{attrs:{id:"自动注册流程图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动注册流程图"}},[t._v("#")]),t._v(" 自动注册流程图")]),t._v(" "),s("p",[t._v("图片链接：https://github.com/yitter/IdGenerator/blob/master/Tools/AutoRegisterWorkerId/regprocess.jpg")]),t._v(" "),s("p",[t._v("源码路径：/Go/source/regworkerid/reghelper.go")]),t._v(" "),s("h4",{attrs:{id:"动态库下载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态库下载"}},[t._v("#")]),t._v(" 动态库下载")]),t._v(" "),s("p",[t._v("下载链接1：https://github.com/yitter/IdGenerator/releases/download/reg_v1.0/regworkerid_lib_v1.0.zip")]),t._v(" "),s("p",[t._v("下载链接2：https://gitee.com/yitter/idgenerator/attach_files/662372/download/regworkerid_lib_v1.0.zip")]),t._v(" "),s("h4",{attrs:{id:"动态库接口定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态库接口定义"}},[t._v("#")]),t._v(" 动态库接口定义")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 注册一个 WorkerId，会先注销所有本机已注册的记录\n// ip: redis 服务器地址\n// port: redis 端口\n// password: redis 访问密码，可为空字符串“”\n// maxWorkerId: 最大 WorkerId\nextern GoInt32 RegisterOne(char* ip, GoInt32 port, char* password, GoInt32 maxWorkerId);\n\n// 注销本机已注册的 WorkerId\nextern void UnRegister();\n\n// 检查本地WorkerId是否有效（0-有效，其它-无效）\nextern GoInt32 Validate(GoInt32 workerId);\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])])])}),[],!1,null,null,null);s.default=r.exports}}]);